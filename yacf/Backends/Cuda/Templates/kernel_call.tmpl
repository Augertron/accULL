/* Begin template: kernel_call , file: kernel_call.tmpl */
<%!
       from Backends.Common.TemplateEngine.Functions import write_as_function_call, is_array, is_pointer, write_as_parameter_definition, rename_if_complex
%>
<%namespace name="declarations" file="device_declaration.tmpl"/>
<%namespace name="transfers" file="device_transfers.tmpl"/>


/* Kernel initialization and call */
 {
 
        #define LLC_REDUCTION_FUNC(dest, source) dest = dest + source
        #define CUDA_NUM_THREADS 64
 
         int dimA = * ${dimA};
         int numThreadsPerBlock = CUDA_NUM_THREADS;
         int numBlocks = dimA / numThreadsPerBlock + (dimA % numThreadsPerBlock?1:0);
         int numElems = numBlocks * numThreadsPerBlock;
         int memSize = numElems * sizeof(double);
         dim3 dimGrid, dimBlock;
 
		   /* Complex types need to be created on device memory */
         ${declarations.write_declarations(kernel_parameters, '', '_cu')}     
         
         /* Initialization of declarations */
         ${declarations.write_allocate_to_device(kernel_parameters, '', '_cu')}     
         ${transfers.write_transfer_to_device(kernel_parameters, '', '_cu')}     

         /* Kernel Launch */
         dimGrid.x = numBlocks;
         dimBlock.x = numThreadsPerBlock;
         ${kernelName} <<< dimGrid, dimBlock >>> (${', '.join(str(var.declaration) + rename_if_complex(var,'_cu')  for var in kernel_parameters)});

        checkCUDAError("memcpy");


        /* By default, omp for has a wait at the end */
        % if not nowait:
            cudaThreadSynchronize();
        % endif

   }


/* End template: kernel_call , file: kernel_call.tmpl */
## ex: set filetype=c
